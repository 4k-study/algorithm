## 문제 설명
어떤 수열의 연속 부분 수열에 같은 길이의 펄스 수열을 각 원소끼리 곱하여 연속 펄스 부분 수열을 만들려 합니다. 펄스 수열이란 [1, -1, 1, -1 …] 또는 [-1, 1, -1, 1 …] 과 같이 1 또는 -1로 시작하면서 1과 -1이 번갈아 나오는 수열입니다.
예를 들어 수열 [2, 3, -6, 1, 3, -1, 2, 4]의 연속 부분 수열 [3, -6, 1]에 펄스 수열 [1, -1, 1]을 곱하면 연속 펄스 부분수열은 [3, 6, 1]이 됩니다. 또 다른 예시로 연속 부분 수열 [3, -1, 2, 4]에 펄스 수열 [-1, 1, -1, 1]을 곱하면 연속 펄스 부분수열은 [-3, -1, -2, 4]이 됩니다.
정수 수열 sequence가 매개변수로 주어질 때, 연속 펄스 부분 수열의 합 중 가장 큰 것을 return 하도록 solution 함수를 완성해주세요.

## 제한 사항
1 ≤ sequence의 길이 ≤ 500,000
-100,000 ≤ sequence의 원소 ≤ 100,000
sequence의 원소는 정수입니다.

## 입출력 예
| `sequence` | `result` |
|----------|--------|
| `[2, 3, -6, 1, 3, -1, 2, 4]` | `10` |

## 입출력 예 설명
주어진 수열의 연속 부분 수열 [3, -6, 1]에 펄스 수열 [1, -1, 1]을 곱하여 연속 펄스 부분 수열 [3, 6, 1]을 얻을 수 있고 그 합은 10으로서 가장 큽니다.

## 풀이
### 파이썬
```python3
def solution(sequence):
    answer = 0
    length = len(sequence)

    if length == 1:
        return abs(sequence[0])
    
    dp = [[0, 0] for _ in range(length)]
    
    for i in range(length):
        if i % 2 == 0:
            dp[i][0] = sequence[i] * -1
            dp[i][1] = sequence[i]
        else:
            dp[i][0] = sequence[i] 
            dp[i][1] = sequence[i] * -1
            
    for i in range(1, length):
        dp[i][0] = max(dp[i][0], dp[i][0] + dp[i - 1][0])
        dp[i][1] = max(dp[i][1], dp[i][1] + dp[i - 1][1])
        answer = max(answer, dp[i][0], dp[i][1])
        
    return answer
```

### 자바
```java
class Solution {
    public long solution(int[] sequence) {
        int length = sequence.length;
        if (length == 1) return Math.abs(sequence[0]);
        
        long answer = 0;
        long[][] dp = new long[length][2];
        
        for (int i = 0; i < length; i++) {
            if (i % 2 == 0) {
                dp[i][0] = sequence[i];
                dp[i][1] = sequence[i] * -1;
            } else {
                dp[i][0] = sequence[i] * -1;
                dp[i][1] = sequence[i];                
            }
        }
        
        for (int i = 1; i < length; i++) {
            dp[i][0] = Math.max(dp[i][0], dp[i][0] + dp[i - 1][0]);
            dp[i][1] = Math.max(dp[i][1], dp[i][1] + dp[i - 1][1]);

            answer = Math.max(answer, dp[i][0]);
            answer = Math.max(answer, dp[i][1]);
        }
        
        return answer;
    }
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/161988?language=python3
